/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset enforces a strict user-ownership model. Each authenticated user has
 * exclusive create, read, update, and delete (CRUD) access to their own profile
 * document. The primary goal is to securely manage user identity and subscription
 * status (`isPro`).
 *
 * ## Data Structure
 * The data structure is flat and user-centric. All data is stored in a top-level
 * `/users` collection. Each user's profile is a single document within this
 * collection, with the document ID matching the user's authentication UID
 * (e.g., `/users/{userId}`).
 *
 * ## Key Security Decisions
 * - **No User Listing**: To protect user privacy and prevent data scraping, it is
 *   explicitly forbidden to list all documents in the `/users` collection, with
 *   the sole exception of querying by email for the password reset flow.
 * - **Ownership Integrity**: When a user profile is created, a rule enforces
 *   that the user's UID is stored inside the document's `id` field. This `id`
 *   field is then made immutable on all subsequent updates, creating a permanent
 *   and trustworthy link between the document data and its owner.
 * - **Default Secure**: Access is denied by default. Permissions are only granted
 *   explicitly.
 *
 * ## Denormalization for Authorization
 * The data model is already optimized for security rules. Authorization-critical
 * data, such as the `isPro` flag, is stored directly on the `/users/{userId}`
 * document. This design choice is deliberate and crucial, as it allows for fast,
 * simple, and cost-effective authorization checks without requiring any slow or
 * expensive `get()` calls to other documents.
 */
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the document's owner ID
     * from the path. This is the primary ownership check.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user is the owner of an existing document. This is crucial
     * for safe updates and deletes, preventing operations on non-existent data.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * On create, validates that the internal 'id' field in the document data
     * matches the document's path ID (`userId`). This enforces relational
     * integrity from the moment of creation.
     */
    function hasValidUserProfileDataOnCreate(userId) {
      return request.resource.data.id == userId
          && request.resource.data.securityQuestion != null
          && request.resource.data.securityAnswer != null;
    }

    /**
     * On update, ensures critical relational fields like the user 'id' and
     * security info are not changed, preserving the integrity of the ownership link.
     */
    function isImmutableUserProfileData() {
      return request.resource.data.id == resource.data.id
        && request.resource.data.securityQuestion == resource.data.securityQuestion
        && request.resource.data.securityAnswer == resource.data.securityAnswer;
    }
    
    /**
     * Checks if an unauthenticated query is specifically for the password reset flow.
     */
    function isPasswordResetQuery() {
      // Rule breakdown:
      // 1. request.auth == null: The user must NOT be authenticated.
      // 2. request.query.keys().hasOnly(['where']): The query must ONLY contain a 'where' clause. No 'orderBy', 'limit', etc.
      // 3. request.query.where[0].field == 'email': The first (and only) 'where' clause must be on the 'email' field.
      // 4. request.query.where[0].operator == '==': The operator must be an exact match.
      return request.auth == null 
        && request.query.keys().hasOnly(['where']) 
        && request.query.where.size() == 1
        && request.query.where[0][0] == 'email' 
        && request.query.where[0][1] == '==';
    }


    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    match /users/{userId} {
      // DOCUMENT Rules: Apply to specific document operations (get, create, update, delete).
      allow get: if isOwner(userId);
      allow create: if isOwner(userId) && hasValidUserProfileDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && isImmutableUserProfileData();
      allow delete: if isExistingOwner(userId);

      // COLLECTION Rules: Apply to queries on the collection.
      // Allow an unauthenticated user to query ONLY by email for the password reset flow.
      allow list: if isPasswordResetQuery();
    }
  }
}

/**
 * # Firestore Security Rules
 *
 * ## Core Philosophy
 * This ruleset enforces a strict user-ownership model. Each authenticated user has
 * exclusive create, read, update, and delete (CRUD) access to their own profile
 * document. The primary goal is to securely manage user identity and subscription
 * status (`isPro`).
 *
 * ## Data Structure
 * The data structure is flat and user-centric. All data is stored in a top-level
 * `/users` collection. Each user's profile is a single document within this
 * collection, with the document ID matching the user's authentication UID
 * (e.g., `/users/{userId}`).
 *
 * ## Key Security Decisions
 * - **No User Listing**: To protect user privacy and prevent data scraping, it is
 *   explicitly forbidden to list all documents in the `/users` collection, with
 *   the sole exception of querying by email for the password reset flow.
 * - **Ownership Integrity**: When a user profile is created, a rule enforces
 *   that the user's UID is stored inside the document's `id` field. This `id`
 *   field is then made immutable on all subsequent updates, creating a permanent
 *   and trustworthy link between the document data and its owner.
 * - **Default Secure**: Access is denied by default. Permissions are only granted
 *   explicitly.
 *
 * ## Denormalization for Authorization
 * The data model is already optimized for security rules. Authorization-critical
 * data, such as the `isPro` flag, is stored directly on the `/users/{userId}`
 * document. This design choice is deliberate and crucial, as it allows for fast,
 * simple, and cost-effective authorization checks without requiring any slow or
 * expensive `get()` calls to other documents.
 */
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the document's owner ID
     * from the path. This is the primary ownership check.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if the user is the owner of an existing document. This is crucial
     * for safe updates and deletes, preventing operations on non-existent data.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * On create, validates that the internal 'id' field in the document data
     * matches the document's path ID (`userId`). This enforces relational
     * integrity from the moment of creation.
     */
    function hasValidUserProfileDataOnCreate(userId) {
      return request.resource.data.id == userId
          && request.resource.data.securityQuestion != null
          && request.resource.data.securityAnswer != null;
    }

    /**
     * On update, ensures critical relational fields like the user 'id' and
     * security info are not changed, preserving the integrity of the ownership link.
     */
    function isImmutableUserProfileData() {
      return request.resource.data.id == resource.data.id
        && request.resource.data.securityQuestion == resource.data.securityQuestion
        && request.resource.data.securityAnswer == resource.data.securityAnswer;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    match /users/{userId} {
      // READS: The owner can read their own profile.
      allow get: if isOwner(userId);
      
      // WRITES: The owner can create, update, and delete their own profile, with data integrity checks.
      allow create: if isOwner(userId) && hasValidUserProfileDataOnCreate(userId);
      allow update: if isExistingOwner(userId) && isImmutableUserProfileData();
      allow delete: if isExistingOwner(userId);

      // LIST: Deny general collection scans, but allow a very specific query by email.
      // This is necessary for the "forgot password" flow to find a user's security question.
      // It only allows fetching documents if the `where` clause exactly matches the email field.
      allow list: if request.query.keys().hasOnly(['where']) && request.query.where.size() == 1 && request.query.where[0].field == 'email';
    }
  }
}
